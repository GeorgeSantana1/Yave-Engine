#version 450

#include "yave.glsl"

// -------------------------------- I/O --------------------------------

layout(local_size_x = 16, local_size_y = 16) in;

layout(set = 0, binding = 0) uniform sampler2D in_depth;
layout(set = 0, binding = 1) uniform sampler2D in_color;
layout(set = 0, binding = 2) uniform sampler2D in_normal;

layout(rgba16f, set = 0, binding = 3) uniform writeonly image2D out_color;

layout(set = 0, binding = 4) readonly buffer Lights {
	Light lights[];
} lights;

struct CameraData {
	mat4 inv_matrix;
	vec3 position;
	uint padding_0;
	vec3 forward;
	uint padding_1;
};

layout(push_constant) uniform PushConstants {
	CameraData camera;
	uint point_count;
	uint directional_count;
} constants;




// -------------------------------- MAIN --------------------------------

void main() {
	ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
	vec2 uv = vec2(gl_GlobalInvocationID.xy) / vec2(gl_NumWorkGroups.xy * gl_WorkGroupSize.xy);

	vec3 albedo;
	float metallic;
	unpack_color(texelFetch(in_color, coord, 0), albedo, metallic);
	float depth = texelFetch(in_depth, coord, 0).x;

	vec3 irradiance = vec3(0.0);

	if(!is_OOB(depth)) {
		vec3 normal;
		float roughness;
		unpack_normal(texelFetch(in_normal, coord, 0), normal, roughness);

		vec3 world_pos = unproject(uv, depth, constants.camera.inv_matrix);
		vec3 view_dir = normalize(constants.camera.position - world_pos);

		// point lights
		for(uint i = 0; i != constants.point_count; ++i) {
			Light light = lights.lights[i];

			// light_dir dot view_dir > 0
			vec3 light_dir = light.position - world_pos;
			float distance = length(light_dir);
			light_dir /= distance;
			float att = attenuation(distance, light.radius);

			vec3 radiance = light.color * att;
			irradiance += radiance * L0(normal, light_dir, view_dir, roughness, metallic, albedo);
		}

		// directional lights
		for(uint i = constants.point_count, end = constants.point_count + constants.directional_count; i != end; ++i) {
			Light light = lights.lights[i];

			vec3 light_dir = light.position; // assume normalized

			vec3 radiance = light.color;
			irradiance += radiance * L0(normal, light_dir, view_dir, roughness, metallic, albedo);
		}
	}

	imageStore(out_color, coord, vec4(irradiance, 1.0));
}


